import { Prisma } from "@prisma/client";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import passport from "passport";
import { ExtractJwt, Strategy as JwtStrategy } from "passport-jwt";

import { PORT } from "@/constants/env";
import dbClient from "@/data/db-client";
import { NextFunction, Request, Response } from "express";
import { HTTPStatusCode } from "@/constants/http";

// TODO: extract???
const JWT_SECRET = "some secret token generated by magic unicorns";
const JWT_ISSUER = `http://localhost:${PORT}`;
const SALT_GENERATION_ROUNDS = 10;
const JWT_AUDIENCE = "http://localhost:3000";

const jwtOptions = {
  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
  secretOrKey: JWT_SECRET,
  issuer: JWT_ISSUER,
  audience: JWT_AUDIENCE,
};

passport.use(
  new JwtStrategy(jwtOptions, async (jwtPayload, done) => {
    try {
      const userId = Number(jwtPayload.sub);

      if (Number.isNaN(userId)) {
        return void done(null, false);
      }

      const user = await dbClient.user.findFirstOrThrow({
        select: {
          id: true,
          email: true,
          firstName: true,
          lastName: true,
          profilePicturePath: true,
          passwordHash: false,
        },
        where: {
          id: userId,
        },
      });

      return void done(null, user);
    } catch (error) {
      return void done(error, false);
    }
  })
);

export { passport };

export async function generatePasswordHash(plainPassword: string) {
  return new Promise<string>((resolve, reject) =>
    bcrypt.hash(
      plainPassword,
      SALT_GENERATION_ROUNDS,
      (error, hashedPassword) => {
        if (error) {
          return void reject(error);
        }

        resolve(hashedPassword);
      }
    )
  );
}

export async function comparePasswords(
  plainPassword: string,
  passwordHash: string
) {
  return new Promise<boolean>((resolve, reject) => {
    bcrypt.compare(plainPassword, passwordHash, (error, areEqual) => {
      if (error) {
        return void reject(error);
      }

      resolve(areEqual);
    });
  });
}

export async function createUser(
  user: Pick<Prisma.UserCreateInput, "email" | "firstName" | "lastName">,
  plainPassword: string
) {
  const hashedPassword = await generatePasswordHash(plainPassword);

  await dbClient.user.create({
    data: { ...user, passwordHash: hashedPassword },
  });
}

export async function login(email: string, passwordAttempt: string) {
  const user = await dbClient.user.findFirst({
    where: {
      email,
    },
  });

  if (!user) {
    return null;
  }

  return jwt.sign({}, JWT_SECRET, {
    subject: user.id.toString(),
    expiresIn: "4h",
    issuer: JWT_ISSUER,
    audience: JWT_AUDIENCE,
  });
}

export const authMiddleware = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  passport.authenticate("jwt", (error: Error, user: Express.User) => {
    if (error) {
      return void next(error);
    }

    if (!user) {
      return void res.status(HTTPStatusCode.Unauthorized).send({
        status: HTTPStatusCode.Unauthorized,
        message:
          "You are not authorized to access this resource. Please log in and try again.",
      });
    }

    req.user = user;

    next();
  })(req, res, next);
};
